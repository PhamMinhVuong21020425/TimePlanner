"use strict";
(self["webpackChunkserver"] = self["webpackChunkserver"] || []).push([["/public/js/vendor~node_modules_echarts_i"],{

/***/ "./node_modules/echarts/index.js":
/*!***************************************!*\
  !*** ./node_modules/echarts/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Axis: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.Axis),
/* harmony export */   ChartView: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.ChartView),
/* harmony export */   ComponentModel: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.ComponentModel),
/* harmony export */   ComponentView: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.ComponentView),
/* harmony export */   List: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.List),
/* harmony export */   Model: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.Model),
/* harmony export */   PRIORITY: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.PRIORITY),
/* harmony export */   SeriesModel: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.SeriesModel),
/* harmony export */   color: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.color),
/* harmony export */   connect: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.connect),
/* harmony export */   dataTool: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.dataTool),
/* harmony export */   dependencies: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.dependencies),
/* harmony export */   disConnect: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.disConnect),
/* harmony export */   disconnect: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.disconnect),
/* harmony export */   dispose: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.dispose),
/* harmony export */   env: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.env),
/* harmony export */   extendChartView: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.extendChartView),
/* harmony export */   extendComponentModel: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.extendComponentModel),
/* harmony export */   extendComponentView: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.extendComponentView),
/* harmony export */   extendSeriesModel: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.extendSeriesModel),
/* harmony export */   format: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.format),
/* harmony export */   getCoordinateSystemDimensions: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.getCoordinateSystemDimensions),
/* harmony export */   getInstanceByDom: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.getInstanceByDom),
/* harmony export */   getInstanceById: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.getInstanceById),
/* harmony export */   getMap: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.getMap),
/* harmony export */   graphic: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.graphic),
/* harmony export */   helper: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.helper),
/* harmony export */   init: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.init),
/* harmony export */   innerDrawElementOnCanvas: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.innerDrawElementOnCanvas),
/* harmony export */   matrix: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.matrix),
/* harmony export */   number: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.number),
/* harmony export */   parseGeoJSON: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.parseGeoJSON),
/* harmony export */   parseGeoJson: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.parseGeoJson),
/* harmony export */   registerAction: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.registerAction),
/* harmony export */   registerCoordinateSystem: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.registerCoordinateSystem),
/* harmony export */   registerLayout: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.registerLayout),
/* harmony export */   registerLoading: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.registerLoading),
/* harmony export */   registerLocale: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.registerLocale),
/* harmony export */   registerMap: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.registerMap),
/* harmony export */   registerPostInit: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.registerPostInit),
/* harmony export */   registerPostUpdate: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.registerPostUpdate),
/* harmony export */   registerPreprocessor: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.registerPreprocessor),
/* harmony export */   registerProcessor: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.registerProcessor),
/* harmony export */   registerTheme: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.registerTheme),
/* harmony export */   registerTransform: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.registerTransform),
/* harmony export */   registerUpdateLifecycle: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.registerUpdateLifecycle),
/* harmony export */   registerVisual: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.registerVisual),
/* harmony export */   setCanvasCreator: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.setCanvasCreator),
/* harmony export */   setPlatformAPI: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.setPlatformAPI),
/* harmony export */   throttle: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.throttle),
/* harmony export */   time: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.time),
/* harmony export */   use: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.use),
/* harmony export */   util: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.util),
/* harmony export */   vector: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.vector),
/* harmony export */   version: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   zrUtil: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.zrUtil),
/* harmony export */   zrender: () => (/* reexport safe */ _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__.zrender)
/* harmony export */ });
/* harmony import */ var _lib_extension_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/extension.js */ "./node_modules/echarts/lib/extension.js");
/* harmony import */ var _lib_export_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/export/core.js */ "./node_modules/echarts/lib/export/core.js");
/* harmony import */ var _lib_export_renderers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/export/renderers.js */ "./node_modules/echarts/lib/renderer/installCanvasRenderer.js");
/* harmony import */ var _lib_export_renderers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/export/renderers.js */ "./node_modules/echarts/lib/renderer/installSVGRenderer.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/line/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/bar/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/pie/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/scatter/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/radar/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/map/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/tree/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/treemap/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/graph/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/gauge/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/funnel/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/parallel/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/sankey/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/boxplot/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/candlestick/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/effectScatter/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/lines/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/heatmap/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/bar/installPictorialBar.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/themeRiver/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/sunburst/install.js");
/* harmony import */ var _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lib/export/charts.js */ "./node_modules/echarts/lib/chart/custom/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/grid/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/polar/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/geo/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/singleAxis/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/parallel/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/calendar/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/graphic/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/toolbox/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/tooltip/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/axisPointer/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/brush/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/title/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/timeline/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/marker/installMarkPoint.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/marker/installMarkLine.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/marker/installMarkArea.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/legend/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/dataZoom/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/dataZoom/installDataZoomInside.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/dataZoom/installDataZoomSlider.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/visualMap/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/visualMap/installVisualMapContinuous.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/visualMap/installVisualMapPiecewise.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/aria/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/transform/install.js");
/* harmony import */ var _lib_export_components_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./lib/export/components.js */ "./node_modules/echarts/lib/component/dataset/install.js");
/* harmony import */ var _lib_export_features_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./lib/export/features.js */ "./node_modules/echarts/lib/animation/universalTransition.js");
/* harmony import */ var _lib_export_features_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./lib/export/features.js */ "./node_modules/echarts/lib/label/installLabelLayout.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

 // ----------------------------------------------
// All of the modules that are allowed to be
// imported are listed below.
//
// Users MUST NOT import other modules that are
// not included in this list.
// ----------------------------------------------




 // -----------------
// Render engines
// -----------------
// Render via Canvas.
// echarts.init(dom, null, { renderer: 'canvas' })

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)([_lib_export_renderers_js__WEBPACK_IMPORTED_MODULE_2__.install]); // Render via SVG.
// echarts.init(dom, null, { renderer: 'svg' })

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)([_lib_export_renderers_js__WEBPACK_IMPORTED_MODULE_3__.install]); // ----------------
// Charts (series)
// ----------------
// All of the series types, for example:
// chart.setOption({
//     series: [{
//         type: 'line' // or 'bar', 'pie', ...
//     }]
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)([_lib_export_charts_js__WEBPACK_IMPORTED_MODULE_4__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_5__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_6__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_7__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_8__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_9__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_10__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_11__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_12__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_13__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_14__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_15__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_16__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_17__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_18__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_19__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_20__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_21__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_22__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_23__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_24__.install, _lib_export_charts_js__WEBPACK_IMPORTED_MODULE_25__.install]); // -------------------
// Coordinate systems
// -------------------
// All of the axis modules have been included in the
// coordinate system module below, do not need to
// make extra import.
// `cartesian` coordinate system. For some historical
// reasons, it is named as grid, for example:
// chart.setOption({
//     grid: {...},
//     xAxis: {...},
//     yAxis: {...},
//     series: [{...}]
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_26__.install); // `polar` coordinate system, for example:
// chart.setOption({
//     polar: {...},
//     radiusAxis: {...},
//     angleAxis: {...},
//     series: [{
//         coordinateSystem: 'polar'
//     }]
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_27__.install); // `geo` coordinate system, for example:
// chart.setOption({
//     geo: {...},
//     series: [{
//         coordinateSystem: 'geo'
//     }]
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_28__.install); // `singleAxis` coordinate system (notice, it is a coordinate system
// with only one axis, work for chart like theme river), for example:
// chart.setOption({
//     singleAxis: {...}
//     series: [{type: 'themeRiver', ...}]
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_29__.install); // `parallel` coordinate system, only work for parallel series, for example:
// chart.setOption({
//     parallel: {...},
//     parallelAxis: [{...}, ...],
//     series: [{
//         type: 'parallel'
//     }]
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_30__.install); // `calendar` coordinate system. for example,
// chart.setOption({
//     calendar: {...},
//     series: [{
//         coordinateSystem: 'calendar'
//     }]
// );

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_31__.install); // ------------------
// Other components
// ------------------
// `graphic` component, for example:
// chart.setOption({
//     graphic: {...}
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_32__.install); // `toolbox` component, for example:
// chart.setOption({
//     toolbox: {...}
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_33__.install); // `tooltip` component, for example:
// chart.setOption({
//     tooltip: {...}
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_34__.install); // `axisPointer` component, for example:
// chart.setOption({
//     tooltip: {axisPointer: {...}, ...}
// });
// Or
// chart.setOption({
//     axisPointer: {...}
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_35__.install); // `brush` component, for example:
// chart.setOption({
//     brush: {...}
// });
// Or
// chart.setOption({
//     tooltip: {feature: {brush: {...}}
// })

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_36__.install); // `title` component, for example:
// chart.setOption({
//     title: {...}
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_37__.install); // `timeline` component, for example:
// chart.setOption({
//     timeline: {...}
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_38__.install); // `markPoint` component, for example:
// chart.setOption({
//     series: [{markPoint: {...}}]
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_39__.install); // `markLine` component, for example:
// chart.setOption({
//     series: [{markLine: {...}}]
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_40__.install); // `markArea` component, for example:
// chart.setOption({
//     series: [{markArea: {...}}]
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_41__.install); // `legend` component not scrollable. for example:
// chart.setOption({
//     legend: {...}
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_42__.install); // `dataZoom` component including both `dataZoomInside` and `dataZoomSlider`.

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_43__.install); // `dataZoom` component providing drag, pinch, wheel behaviors
// inside coordinate system, for example:
// chart.setOption({
//     dataZoom: {type: 'inside'}
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_44__.install); // `dataZoom` component providing a slider bar, for example:
// chart.setOption({
//     dataZoom: {type: 'slider'}
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_45__.install); // `visualMap` component including both `visualMapContinuous` and `visualMapPiecewise`.

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_46__.install); // `visualMap` component providing continuous bar, for example:
// chart.setOption({
//     visualMap: {type: 'continuous'}
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_47__.install); // `visualMap` component providing pieces bar, for example:
// chart.setOption({
//     visualMap: {type: 'piecewise'}
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_48__.install); // `aria` component providing aria, for example:
// chart.setOption({
//     aria: {...}
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_49__.install); // dataset transform
// chart.setOption({
//     dataset: {
//          transform: []
//     }
// });

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_50__.install);
(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_components_js__WEBPACK_IMPORTED_MODULE_51__.install); // universal transition
// chart.setOption({
//     series: {
//         universalTransition: { enabled: true }
//     }
// })

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_features_js__WEBPACK_IMPORTED_MODULE_52__.installUniversalTransition); // label layout
// chart.setOption({
//     series: {
//         labelLayout: { hideOverlap: true }
//     }
// })

(0,_lib_extension_js__WEBPACK_IMPORTED_MODULE_1__.use)(_lib_export_features_js__WEBPACK_IMPORTED_MODULE_53__.installLabelLayout);

/***/ }),

/***/ "./node_modules/echarts/lib/action/roamHelper.js":
/*!*******************************************************!*\
  !*** ./node_modules/echarts/lib/action/roamHelper.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   updateCenterAndZoom: () => (/* binding */ updateCenterAndZoom)
/* harmony export */ });

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
function getCenterCoord(view, point) {
  // Use projected coord as center because it's linear.
  return view.pointToProjected ? view.pointToProjected(point) : view.pointToData(point);
}

function updateCenterAndZoom(view, payload, zoomLimit, api) {
  var previousZoom = view.getZoom();
  var center = view.getCenter();
  var zoom = payload.zoom;
  var point = view.projectedToPoint ? view.projectedToPoint(center) : view.dataToPoint(center);

  if (payload.dx != null && payload.dy != null) {
    point[0] -= payload.dx;
    point[1] -= payload.dy;
    view.setCenter(getCenterCoord(view, point), api);
  }

  if (zoom != null) {
    if (zoomLimit) {
      var zoomMin = zoomLimit.min || 0;
      var zoomMax = zoomLimit.max || Infinity;
      zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom;
    } // Zoom on given point(originX, originY)


    view.scaleX *= zoom;
    view.scaleY *= zoom;
    var fixX = (payload.originX - view.x) * (zoom - 1);
    var fixY = (payload.originY - view.y) * (zoom - 1);
    view.x -= fixX;
    view.y -= fixY;
    view.updateTransform(); // Get the new center

    view.setCenter(getCenterCoord(view, point), api);
    view.setZoom(zoom * previousZoom);
  }

  return {
    center: view.getCenter(),
    zoom: view.getZoom()
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/animation/basicTransition.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts/lib/animation/basicTransition.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getAnimationConfig: () => (/* binding */ getAnimationConfig),
/* harmony export */   getOldStyle: () => (/* binding */ getOldStyle),
/* harmony export */   initProps: () => (/* binding */ initProps),
/* harmony export */   isElementRemoved: () => (/* binding */ isElementRemoved),
/* harmony export */   removeElement: () => (/* binding */ removeElement),
/* harmony export */   removeElementWithFadeOut: () => (/* binding */ removeElementWithFadeOut),
/* harmony export */   saveOldStyle: () => (/* binding */ saveOldStyle),
/* harmony export */   transitionStore: () => (/* binding */ transitionStore),
/* harmony export */   updateProps: () => (/* binding */ updateProps)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util.js */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/model.js */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

 // Stored properties for further transition.

var transitionStore = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__.makeInner)();
/**
 * Return null if animation is disabled.
 */

function getAnimationConfig(animationType, animatableModel, dataIndex, // Extra opts can override the option in animatable model.
extraOpts, // TODO It's only for pictorial bar now.
extraDelayParams) {
  var animationPayload; // Check if there is global animation configuration from dataZoom/resize can override the config in option.
  // If animation is enabled. Will use this animation config in payload.
  // If animation is disabled. Just ignore it.

  if (animatableModel && animatableModel.ecModel) {
    var updatePayload = animatableModel.ecModel.getUpdatePayload();
    animationPayload = updatePayload && updatePayload.animation;
  }

  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
  var isUpdate = animationType === 'update';

  if (animationEnabled) {
    var duration = void 0;
    var easing = void 0;
    var delay = void 0;

    if (extraOpts) {
      duration = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(extraOpts.duration, 200);
      easing = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.retrieve2)(extraOpts.easing, 'cubicOut');
      delay = 0;
    } else {
      duration = animatableModel.getShallow(isUpdate ? 'animationDurationUpdate' : 'animationDuration');
      easing = animatableModel.getShallow(isUpdate ? 'animationEasingUpdate' : 'animationEasing');
      delay = animatableModel.getShallow(isUpdate ? 'animationDelayUpdate' : 'animationDelay');
    } // animation from payload has highest priority.


    if (animationPayload) {
      animationPayload.duration != null && (duration = animationPayload.duration);
      animationPayload.easing != null && (easing = animationPayload.easing);
      animationPayload.delay != null && (delay = animationPayload.delay);
    }

    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(delay)) {
      delay = delay(dataIndex, extraDelayParams);
    }

    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(duration)) {
      duration = duration(dataIndex);
    }

    var config = {
      duration: duration || 0,
      delay: delay,
      easing: easing
    };
    return config;
  } else {
    return null;
  }
}

function animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {
  var isFrom = false;
  var removeOpt;

  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataIndex)) {
    during = cb;
    cb = dataIndex;
    dataIndex = null;
  } else if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(dataIndex)) {
    cb = dataIndex.cb;
    during = dataIndex.during;
    isFrom = dataIndex.isFrom;
    removeOpt = dataIndex.removeOpt;
    dataIndex = dataIndex.dataIndex;
  }

  var isRemove = animationType === 'leave';

  if (!isRemove) {
    // Must stop the remove animation.
    el.stopAnimation('leave');
  }

  var animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);

  if (animationConfig && animationConfig.duration > 0) {
    var duration = animationConfig.duration;
    var animationDelay = animationConfig.delay;
    var animationEasing = animationConfig.easing;
    var animateConfig = {
      duration: duration,
      delay: animationDelay || 0,
      easing: animationEasing,
      done: cb,
      force: !!cb || !!during,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !isRemove,
      scope: animationType,
      during: during
    };
    isFrom ? el.animateFrom(props, animateConfig) : el.animateTo(props, animateConfig);
  } else {
    el.stopAnimation(); // If `isFrom`, the props is the "from" props.

    !isFrom && el.attr(props); // Call during at least once.

    during && during(1);
    cb && cb();
  }
}
/**
 * Update graphic element properties with or without animation according to the
 * configuration in series.
 *
 * Caution: this method will stop previous animation.
 * So do not use this method to one element twice before
 * animation starts, unless you know what you are doing.
 * @example
 *     graphic.updateProps(el, {
 *         position: [100, 100]
 *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });
 *     // Or
 *     graphic.updateProps(el, {
 *         position: [100, 100]
 *     }, seriesModel, function () { console.log('Animation done!'); });
 */


function updateProps(el, props, // TODO: TYPE AnimatableModel
animatableModel, dataIndex, cb, during) {
  animateOrSetProps('update', el, props, animatableModel, dataIndex, cb, during);
}


/**
 * Init graphic element properties with or without animation according to the
 * configuration in series.
 *
 * Caution: this method will stop previous animation.
 * So do not use this method to one element twice before
 * animation starts, unless you know what you are doing.
 */

function initProps(el, props, animatableModel, dataIndex, cb, during) {
  animateOrSetProps('enter', el, props, animatableModel, dataIndex, cb, during);
}
/**
 * If element is removed.
 * It can determine if element is having remove animation.
 */

function isElementRemoved(el) {
  if (!el.__zr) {
    return true;
  }

  for (var i = 0; i < el.animators.length; i++) {
    var animator = el.animators[i];

    if (animator.scope === 'leave') {
      return true;
    }
  }

  return false;
}
/**
 * Remove graphic element
 */

function removeElement(el, props, animatableModel, dataIndex, cb, during) {
  // Don't do remove animation twice.
  if (isElementRemoved(el)) {
    return;
  }

  animateOrSetProps('leave', el, props, animatableModel, dataIndex, cb, during);
}

function fadeOutDisplayable(el, animatableModel, dataIndex, done) {
  el.removeTextContent();
  el.removeTextGuideLine();
  removeElement(el, {
    style: {
      opacity: 0
    }
  }, animatableModel, dataIndex, done);
}

function removeElementWithFadeOut(el, animatableModel, dataIndex) {
  function doRemove() {
    el.parent && el.parent.remove(el);
  } // Hide label and labelLine first
  // TODO Also use fade out animation?


  if (!el.isGroup) {
    fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);
  } else {
    el.traverse(function (disp) {
      if (!disp.isGroup) {
        // Can invoke doRemove multiple times.
        fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);
      }
    });
  }
}
/**
 * Save old style for style transition in universalTransition module.
 * It's used when element will be reused in each render.
 * For chart like map, heatmap, which will always create new element.
 * We don't need to save this because universalTransition can get old style from the old element
 */

function saveOldStyle(el) {
  transitionStore(el).oldStyle = el.style;
}
function getOldStyle(el) {
  return transitionStore(el).oldStyle;
}

/***/ }),

/***/ "./node_modules/echarts/lib/animation/customGraphicKeyframeAnimation.js":
/*!******************************************************************************!*\
  !*** ./node_modules/echarts/lib/animation/customGraphicKeyframeAnimation.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyKeyframeAnimation: () => (/* binding */ applyKeyframeAnimation),
/* harmony export */   stopPreviousKeyframeAnimationAndRestore: () => (/* binding */ stopPreviousKeyframeAnimationAndRestore)
/* harmony export */ });
/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util.js */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _customGraphicTransition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./customGraphicTransition.js */ "./node_modules/echarts/lib/animation/customGraphicTransition.js");
/* harmony import */ var _basicTransition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basicTransition.js */ "./node_modules/echarts/lib/animation/basicTransition.js");
/* harmony import */ var _util_log_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/log.js */ "./node_modules/echarts/lib/util/log.js");
/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/model.js */ "./node_modules/echarts/lib/util/model.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/





var getStateToRestore = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__.makeInner)();
var KEYFRAME_EXCLUDE_KEYS = ['percent', 'easing', 'shape', 'style', 'extra'];
/**
 * Stop previous keyframe animation and restore the attributes.
 * Avoid new keyframe animation starts with wrong internal state when the percent: 0 is not set.
 */

function stopPreviousKeyframeAnimationAndRestore(el) {
  // Stop previous keyframe animation.
  el.stopAnimation('keyframe'); // Restore

  el.attr(getStateToRestore(el));
}
function applyKeyframeAnimation(el, animationOpts, animatableModel) {
  if (!animatableModel.isAnimationEnabled() || !animationOpts) {
    return;
  }

  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(animationOpts)) {
    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(animationOpts, function (singleAnimationOpts) {
      applyKeyframeAnimation(el, singleAnimationOpts, animatableModel);
    });
    return;
  }

  var keyframes = animationOpts.keyframes;
  var duration = animationOpts.duration;

  if (animatableModel && duration == null) {
    // Default to use duration of config.
    // NOTE: animation config from payload will be ignored because they are mainly for transitions.
    var config = (0,_basicTransition_js__WEBPACK_IMPORTED_MODULE_2__.getAnimationConfig)('enter', animatableModel, 0);
    duration = config && config.duration;
  }

  if (!keyframes || !duration) {
    return;
  }

  var stateToRestore = getStateToRestore(el);
  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(_customGraphicTransition_js__WEBPACK_IMPORTED_MODULE_3__.ELEMENT_ANIMATABLE_PROPS, function (targetPropName) {
    if (targetPropName && !el[targetPropName]) {
      return;
    }

    var animator;
    var endFrameIsSet = false; // Sort keyframes by percent.

    keyframes.sort(function (a, b) {
      return a.percent - b.percent;
    });
    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(keyframes, function (kf) {
      // Stop current animation.
      var animators = el.animators;
      var kfValues = targetPropName ? kf[targetPropName] : kf;

      if (true) {
        if (kf.percent >= 1) {
          endFrameIsSet = true;
        }
      }

      if (!kfValues) {
        return;
      }

      var propKeys = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.keys)(kfValues);

      if (!targetPropName) {
        // PENDING performance?
        propKeys = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.filter)(propKeys, function (key) {
          return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.indexOf)(KEYFRAME_EXCLUDE_KEYS, key) < 0;
        });
      }

      if (!propKeys.length) {
        return;
      }

      if (!animator) {
        animator = el.animate(targetPropName, animationOpts.loop, true);
        animator.scope = 'keyframe';
      }

      for (var i = 0; i < animators.length; i++) {
        // Stop all other animation that is not keyframe.
        if (animators[i] !== animator && animators[i].targetName === animator.targetName) {
          animators[i].stopTracks(propKeys);
        }
      }

      targetPropName && (stateToRestore[targetPropName] = stateToRestore[targetPropName] || {});
      var savedTarget = targetPropName ? stateToRestore[targetPropName] : stateToRestore;
      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(propKeys, function (key) {
        // Save original value.
        savedTarget[key] = ((targetPropName ? el[targetPropName] : el) || {})[key];
      });
      animator.whenWithKeys(duration * kf.percent, kfValues, propKeys, kf.easing);
    });

    if (!animator) {
      return;
    }

    if (true) {
      if (!endFrameIsSet) {
        (0,_util_log_js__WEBPACK_IMPORTED_MODULE_4__.warn)('End frame with percent: 1 is missing in the keyframeAnimation.', true);
      }
    }

    animator.delay(animationOpts.delay || 0).duration(duration).start(animationOpts.easing);
  });
}

/***/ }),

/***/ "./node_modules/echarts/lib/animation/customGraphicTransition.js":
/*!***********************************************************************!*\
  !*** ./node_modules/echarts/lib/animation/customGraphicTransition.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ELEMENT_ANIMATABLE_PROPS: () => (/* binding */ ELEMENT_ANIMATABLE_PROPS),
/* harmony export */   applyLeaveTransition: () => (/* binding */ applyLeaveTransition),
/* harmony export */   applyUpdateTransition: () => (/* binding */ applyUpdateTransition),
/* harmony export */   isTransitionAll: () => (/* binding */ isTransitionAll),
/* harmony export */   updateLeaveTo: () => (/* binding */ updateLeaveTo)
/* harmony export */ });
/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/model.js */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util.js */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var zrender_lib_animation_Animator_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! zrender/lib/animation/Animator.js */ "./node_modules/zrender/lib/animation/Animator.js");
/* harmony import */ var zrender_lib_graphic_Displayable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zrender/lib/graphic/Displayable.js */ "./node_modules/zrender/lib/graphic/Displayable.js");
/* harmony import */ var _basicTransition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basicTransition.js */ "./node_modules/echarts/lib/animation/basicTransition.js");
/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/graphic.js */ "./node_modules/zrender/lib/graphic/Path.js");
/* harmony import */ var _util_log_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/log.js */ "./node_modules/echarts/lib/util/log.js");
/* harmony import */ var zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/Transformable.js */ "./node_modules/zrender/lib/core/Transformable.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/








var LEGACY_TRANSFORM_PROPS_MAP = {
  position: ['x', 'y'],
  scale: ['scaleX', 'scaleY'],
  origin: ['originX', 'originY']
};
var LEGACY_TRANSFORM_PROPS = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.keys)(LEGACY_TRANSFORM_PROPS_MAP);
var TRANSFORM_PROPS_MAP = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.reduce)(zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_1__.TRANSFORMABLE_PROPS, function (obj, key) {
  obj[key] = 1;
  return obj;
}, {});
var transformPropNamesStr = zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_1__.TRANSFORMABLE_PROPS.join(', '); // '' means root

var ELEMENT_ANIMATABLE_PROPS = ['', 'style', 'shape', 'extra'];
;
var transitionInnerStore = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_2__.makeInner)();
;

function getElementAnimationConfig(animationType, el, elOption, parentModel, dataIndex) {
  var animationProp = animationType + "Animation";
  var config = (0,_basicTransition_js__WEBPACK_IMPORTED_MODULE_3__.getAnimationConfig)(animationType, parentModel, dataIndex) || {};
  var userDuring = transitionInnerStore(el).userDuring; // Only set when duration is > 0 and it's need to be animated.

  if (config.duration > 0) {
    // For simplicity, if during not specified, the previous during will not work any more.
    config.during = userDuring ? (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.bind)(duringCall, {
      el: el,
      userDuring: userDuring
    }) : null;
    config.setToFinal = true;
    config.scope = animationType;
  }

  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend)(config, elOption[animationProp]);
  return config;
}

function applyUpdateTransition(el, elOption, animatableModel, opts) {
  opts = opts || {};
  var dataIndex = opts.dataIndex,
      isInit = opts.isInit,
      clearStyle = opts.clearStyle;
  var hasAnimation = animatableModel.isAnimationEnabled(); // Save the meta info for further morphing. Like apply on the sub morphing elements.

  var store = transitionInnerStore(el);
  var styleOpt = elOption.style;
  store.userDuring = elOption.during;
  var transFromProps = {};
  var propsToSet = {};
  prepareTransformAllPropsFinal(el, elOption, propsToSet);
  prepareShapeOrExtraAllPropsFinal('shape', elOption, propsToSet);
  prepareShapeOrExtraAllPropsFinal('extra', elOption, propsToSet);

  if (!isInit && hasAnimation) {
    prepareTransformTransitionFrom(el, elOption, transFromProps);
    prepareShapeOrExtraTransitionFrom('shape', el, elOption, transFromProps);
    prepareShapeOrExtraTransitionFrom('extra', el, elOption, transFromProps);
    prepareStyleTransitionFrom(el, elOption, styleOpt, transFromProps);
  }

  propsToSet.style = styleOpt;
  applyPropsDirectly(el, propsToSet, clearStyle);
  applyMiscProps(el, elOption);

  if (hasAnimation) {
    if (isInit) {
      var enterFromProps_1 = {};
      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(ELEMENT_ANIMATABLE_PROPS, function (propName) {
        var prop = propName ? elOption[propName] : elOption;

        if (prop && prop.enterFrom) {
          if (propName) {
            enterFromProps_1[propName] = enterFromProps_1[propName] || {};
          }

          (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend)(propName ? enterFromProps_1[propName] : enterFromProps_1, prop.enterFrom);
        }
      });
      var config = getElementAnimationConfig('enter', el, elOption, animatableModel, dataIndex);

      if (config.duration > 0) {
        el.animateFrom(enterFromProps_1, config);
      }
    } else {
      applyPropsTransition(el, elOption, dataIndex || 0, animatableModel, transFromProps);
    }
  } // Store leave to be used in leave transition.


  updateLeaveTo(el, elOption);
  styleOpt ? el.dirty() : el.markRedraw();
}
function updateLeaveTo(el, elOption) {
  // Try merge to previous set leaveTo
  var leaveToProps = transitionInnerStore(el).leaveToProps;

  for (var i = 0; i < ELEMENT_ANIMATABLE_PROPS.length; i++) {
    var propName = ELEMENT_ANIMATABLE_PROPS[i];
    var prop = propName ? elOption[propName] : elOption;

    if (prop && prop.leaveTo) {
      if (!leaveToProps) {
        leaveToProps = transitionInnerStore(el).leaveToProps = {};
      }

      if (propName) {
        leaveToProps[propName] = leaveToProps[propName] || {};
      }

      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend)(propName ? leaveToProps[propName] : leaveToProps, prop.leaveTo);
    }
  }
}
function applyLeaveTransition(el, elOption, animatableModel, onRemove) {
  if (el) {
    var parent_1 = el.parent;
    var leaveToProps = transitionInnerStore(el).leaveToProps;

    if (leaveToProps) {
      // TODO TODO use leave after leaveAnimation in series is introduced
      // TODO Data index?
      var config = getElementAnimationConfig('update', el, elOption, animatableModel, 0);

      config.done = function () {
        parent_1.remove(el);
        onRemove && onRemove();
      };

      el.animateTo(leaveToProps, config);
    } else {
      parent_1.remove(el);
      onRemove && onRemove();
    }
  }
}
function isTransitionAll(transition) {
  return transition === 'all';
}

function applyPropsDirectly(el, // Can be null/undefined
allPropsFinal, clearStyle) {
  var styleOpt = allPropsFinal.style;

  if (!el.isGroup && styleOpt) {
    if (clearStyle) {
      el.useStyle({}); // When style object changed, how to trade the existing animation?
      // It is probably complicated and not needed to cover all the cases.
      // But still need consider the case:
      // (1) When using init animation on `style.opacity`, and before the animation
      //     ended users triggers an update by mousewhel. At that time the init
      //     animation should better be continued rather than terminated.
      //     So after `useStyle` called, we should change the animation target manually
      //     to continue the effect of the init animation.
      // (2) PENDING: If the previous animation targeted at a `val1`, and currently we need
      //     to update the value to `val2` and no animation declared, should be terminate
      //     the previous animation or just modify the target of the animation?
      //     Therotically That will happen not only on `style` but also on `shape` and
      //     `transfrom` props. But we haven't handle this case at present yet.
      // (3) PENDING: Is it proper to visit `animators` and `targetName`?

      var animators = el.animators;

      for (var i = 0; i < animators.length; i++) {
        var animator = animators[i]; // targetName is the "topKey".

        if (animator.targetName === 'style') {
          animator.changeTarget(el.style);
        }
      }
    }

    el.setStyle(styleOpt);
  }

  if (allPropsFinal) {
    // Not set style here.
    allPropsFinal.style = null; // Set el to the final state firstly.

    allPropsFinal && el.attr(allPropsFinal);
    allPropsFinal.style = styleOpt;
  }
}

function applyPropsTransition(el, elOption, dataIndex, model, // Can be null/undefined
transFromProps) {
  if (transFromProps) {
    var config = getElementAnimationConfig('update', el, elOption, model, dataIndex);

    if (config.duration > 0) {
      el.animateFrom(transFromProps, config);
    }
  }
}

function applyMiscProps(el, elOption) {
  // Merge by default.
  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(elOption, 'silent') && (el.silent = elOption.silent);
  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(elOption, 'ignore') && (el.ignore = elOption.ignore);

  if (el instanceof zrender_lib_graphic_Displayable_js__WEBPACK_IMPORTED_MODULE_4__["default"]) {
    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(elOption, 'invisible') && (el.invisible = elOption.invisible);
  }

  if (el instanceof _util_graphic_js__WEBPACK_IMPORTED_MODULE_5__["default"]) {
    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(elOption, 'autoBatch') && (el.autoBatch = elOption.autoBatch);
  }
} // Use it to avoid it be exposed to user.


var tmpDuringScope = {};
var transitionDuringAPI = {
  // Usually other props do not need to be changed in animation during.
  setTransform: function (key, val) {
    if (true) {
      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(TRANSFORM_PROPS_MAP, key), 'Only ' + transformPropNamesStr + ' available in `setTransform`.');
    }

    tmpDuringScope.el[key] = val;
    return this;
  },
  getTransform: function (key) {
    if (true) {
      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.assert)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(TRANSFORM_PROPS_MAP, key), 'Only ' + transformPropNamesStr + ' available in `getTransform`.');
    }

    return tmpDuringScope.el[key];
  },
  setShape: function (key, val) {
    if (true) {
      assertNotReserved(key);
    }

    var el = tmpDuringScope.el;
    var shape = el.shape || (el.shape = {});
    shape[key] = val;
    el.dirtyShape && el.dirtyShape();
    return this;
  },
  getShape: function (key) {
    if (true) {
      assertNotReserved(key);
    }

    var shape = tmpDuringScope.el.shape;

    if (shape) {
      return shape[key];
    }
  },
  setStyle: function (key, val) {
    if (true) {
      assertNotReserved(key);
    }

    var el = tmpDuringScope.el;
    var style = el.style;

    if (style) {
      if (true) {
        if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.eqNaN)(val)) {
          (0,_util_log_js__WEBPACK_IMPORTED_MODULE_6__.warn)('style.' + key + ' must not be assigned with NaN.');
        }
      }

      style[key] = val;
      el.dirtyStyle && el.dirtyStyle();
    }

    return this;
  },
  getStyle: function (key) {
    if (true) {
      assertNotReserved(key);
    }

    var style = tmpDuringScope.el.style;

    if (style) {
      return style[key];
    }
  },
  setExtra: function (key, val) {
    if (true) {
      assertNotReserved(key);
    }

    var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});
    extra[key] = val;
    return this;
  },
  getExtra: function (key) {
    if (true) {
      assertNotReserved(key);
    }

    var extra = tmpDuringScope.el.extra;

    if (extra) {
      return extra[key];
    }
  }
};

function assertNotReserved(key) {
  if (true) {
    if (key === 'transition' || key === 'enterFrom' || key === 'leaveTo') {
      throw new Error('key must not be "' + key + '"');
    }
  }
}

function duringCall() {
  // Do not provide "percent" until some requirements come.
  // Because consider thies case:
  // enterFrom: {x: 100, y: 30}, transition: 'x'.
  // And enter duration is different from update duration.
  // Thus it might be confused about the meaning of "percent" in during callback.
  var scope = this;
  var el = scope.el;

  if (!el) {
    return;
  } // If el is remove from zr by reason like legend, during still need to called,
  // because el will be added back to zr and the prop value should not be incorrect.


  var latestUserDuring = transitionInnerStore(el).userDuring;
  var scopeUserDuring = scope.userDuring; // Ensured a during is only called once in each animation frame.
  // If a during is called multiple times in one frame, maybe some users' calculation logic
  // might be wrong (not sure whether this usage exists).
  // The case of a during might be called twice can be: by default there is a animator for
  // 'x', 'y' when init. Before the init animation finished, call `setOption` to start
  // another animators for 'style'/'shape'/'extra'.

  if (latestUserDuring !== scopeUserDuring) {
    // release
    scope.el = scope.userDuring = null;
    return;
  }

  tmpDuringScope.el = el; // Give no `this` to user in "during" calling.

  scopeUserDuring(transitionDuringAPI); // FIXME: if in future meet the case that some prop will be both modified in `during` and `state`,
  // consider the issue that the prop might be incorrect when return to "normal" state.
}

function prepareShapeOrExtraTransitionFrom(mainAttr, fromEl, elOption, transFromProps) {
  var attrOpt = elOption[mainAttr];

  if (!attrOpt) {
    return;
  }

  var elPropsInAttr = fromEl[mainAttr];
  var transFromPropsInAttr;

  if (elPropsInAttr) {
    var transition = elOption.transition;
    var attrTransition = attrOpt.transition;

    if (attrTransition) {
      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});

      if (isTransitionAll(attrTransition)) {
        (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.extend)(transFromPropsInAttr, elPropsInAttr);
      } else {
        var transitionKeys = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_2__.normalizeToArray)(attrTransition);

        for (var i = 0; i < transitionKeys.length; i++) {
          var key = transitionKeys[i];
          var elVal = elPropsInAttr[key];
          transFromPropsInAttr[key] = elVal;
        }
      }
    } else if (isTransitionAll(transition) || (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.indexOf)(transition, mainAttr) >= 0) {
      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
      var elPropsInAttrKeys = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.keys)(elPropsInAttr);

      for (var i = 0; i < elPropsInAttrKeys.length; i++) {
        var key = elPropsInAttrKeys[i];
        var elVal = elPropsInAttr[key];

        if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {
          transFromPropsInAttr[key] = elVal;
        }
      }
    }
  }
}

function prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {
  var attrOpt = elOption[mainAttr];

  if (!attrOpt) {
    return;
  }

  var allPropsInAttr = allProps[mainAttr] = {};
  var keysInAttr = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.keys)(attrOpt);

  for (var i = 0; i < keysInAttr.length; i++) {
    var key = keysInAttr[i]; // To avoid share one object with different element, and
    // to avoid user modify the object inexpectedly, have to clone.

    allPropsInAttr[key] = (0,zrender_lib_animation_Animator_js__WEBPACK_IMPORTED_MODULE_7__.cloneValue)(attrOpt[key]);
  }
}

function prepareTransformTransitionFrom(el, elOption, transFromProps) {
  var transition = elOption.transition;
  var transitionKeys = isTransitionAll(transition) ? zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_1__.TRANSFORMABLE_PROPS : (0,_util_model_js__WEBPACK_IMPORTED_MODULE_2__.normalizeToArray)(transition || []);

  for (var i = 0; i < transitionKeys.length; i++) {
    var key = transitionKeys[i];

    if (key === 'style' || key === 'shape' || key === 'extra') {
      continue;
    }

    var elVal = el[key];

    if (true) {
      checkTransformPropRefer(key, 'el.transition');
    } // Do not clone, animator will perform that clone.


    transFromProps[key] = elVal;
  }
}

function prepareTransformAllPropsFinal(el, elOption, allProps) {
  for (var i = 0; i < LEGACY_TRANSFORM_PROPS.length; i++) {
    var legacyName = LEGACY_TRANSFORM_PROPS[i];
    var xyName = LEGACY_TRANSFORM_PROPS_MAP[legacyName];
    var legacyArr = elOption[legacyName];

    if (legacyArr) {
      allProps[xyName[0]] = legacyArr[0];
      allProps[xyName[1]] = legacyArr[1];
    }
  }

  for (var i = 0; i < zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_1__.TRANSFORMABLE_PROPS.length; i++) {
    var key = zrender_lib_core_Transformable_js__WEBPACK_IMPORTED_MODULE_1__.TRANSFORMABLE_PROPS[i];

    if (elOption[key] != null) {
      allProps[key] = elOption[key];
    }
  }
}

function prepareStyleTransitionFrom(fromEl, elOption, styleOpt, transFromProps) {
  if (!styleOpt) {
    return;
  }

  var fromElStyle = fromEl.style;
  var transFromStyleProps;

  if (fromElStyle) {
    var styleTransition = styleOpt.transition;
    var elTransition = elOption.transition;

    if (styleTransition && !isTransitionAll(styleTransition)) {
      var transitionKeys = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_2__.normalizeToArray)(styleTransition);
      !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});

      for (var i = 0; i < transitionKeys.length; i++) {
        var key = transitionKeys[i];
        var elVal = fromElStyle[key]; // Do not clone, see `checkNonStyleTansitionRefer`.

        transFromStyleProps[key] = elVal;
      }
    } else if (fromEl.getAnimationStyleProps && (isTransitionAll(elTransition) || isTransitionAll(styleTransition) || (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.indexOf)(elTransition, 'style') >= 0)) {
      var animationProps = fromEl.getAnimationStyleProps();
      var animationStyleProps = animationProps ? animationProps.style : null;

      if (animationStyleProps) {
        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
        var styleKeys = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.keys)(styleOpt);

        for (var i = 0; i < styleKeys.length; i++) {
          var key = styleKeys[i];

          if (animationStyleProps[key]) {
            var elVal = fromElStyle[key];
            transFromStyleProps[key] = elVal;
          }
        }
      }
    }
  }
}

function isNonStyleTransitionEnabled(optVal, elVal) {
  // The same as `checkNonStyleTansitionRefer`.
  return !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArrayLike)(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;
}

var checkTransformPropRefer;

if (true) {
  checkTransformPropRefer = function (key, usedIn) {
    if (!(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(TRANSFORM_PROPS_MAP, key)) {
      (0,_util_log_js__WEBPACK_IMPORTED_MODULE_6__.warn)('Prop `' + key + '` is not a permitted in `' + usedIn + '`. ' + 'Only `' + (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.keys)(TRANSFORM_PROPS_MAP).join('`, `') + '` are permitted.');
    }
  };
}

/***/ }),

/***/ "./node_modules/echarts/lib/animation/morphTransitionHelper.js":
/*!*********************************************************************!*\
  !*** ./node_modules/echarts/lib/animation/morphTransitionHelper.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyMorphAnimation: () => (/* binding */ applyMorphAnimation),
/* harmony export */   getPathList: () => (/* binding */ getPathList)
/* harmony export */ });
/* harmony import */ var zrender_lib_tool_morphPath_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/tool/morphPath.js */ "./node_modules/zrender/lib/tool/morphPath.js");
/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/graphic.js */ "./node_modules/zrender/lib/graphic/Path.js");
/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zrender/lib/core/util.js */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _basicTransition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basicTransition.js */ "./node_modules/echarts/lib/animation/basicTransition.js");
/* harmony import */ var zrender_lib_tool_path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/tool/path.js */ "./node_modules/zrender/lib/tool/path.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/






function isMultiple(elements) {
  return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(elements[0]);
}

function prepareMorphBatches(one, many) {
  var batches = [];
  var batchCount = one.length;

  for (var i = 0; i < batchCount; i++) {
    batches.push({
      one: one[i],
      many: []
    });
  }

  for (var i = 0; i < many.length; i++) {
    var len = many[i].length;
    var k = void 0;

    for (k = 0; k < len; k++) {
      batches[k % batchCount].many.push(many[i][k]);
    }
  }

  var off = 0; // If one has more paths than each one of many. average them.

  for (var i = batchCount - 1; i >= 0; i--) {
    if (!batches[i].many.length) {
      var moveFrom = batches[off].many;

      if (moveFrom.length <= 1) {
        // Not enough
        // Start from the first one.
        if (off) {
          off = 0;
        } else {
          return batches;
        }
      }

      var len = moveFrom.length;
      var mid = Math.ceil(len / 2);
      batches[i].many = moveFrom.slice(mid, len);
      batches[off].many = moveFrom.slice(0, mid);
      off++;
    }
  }

  return batches;
}

var pathDividers = {
  clone: function (params) {
    var ret = []; // Fitting the alpha

    var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);

    for (var i = 0; i < params.count; i++) {
      var cloned = (0,zrender_lib_tool_path_js__WEBPACK_IMPORTED_MODULE_1__.clonePath)(params.path);
      cloned.setStyle('opacity', approxOpacity);
      ret.push(cloned);
    }

    return ret;
  },
  // Use the default divider
  split: null
};
function applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {
  if (!from.length || !to.length) {
    return;
  }

  var updateAnimationCfg = (0,_basicTransition_js__WEBPACK_IMPORTED_MODULE_2__.getAnimationConfig)('update', seriesModel, dataIndex);

  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {
    return;
  }

  var animationDelay = seriesModel.getModel('universalTransition').get('delay');
  var animationCfg = Object.assign({
    // Need to setToFinal so the further calculation based on the style can be correct.
    // Like emphasis color.
    setToFinal: true
  }, updateAnimationCfg);
  var many;
  var one;

  if (isMultiple(from)) {
    // manyToOne
    many = from;
    one = to;
  }

  if (isMultiple(to)) {
    // oneToMany
    many = to;
    one = from;
  }

  function morphOneBatch(batch, fromIsMany, animateIndex, animateCount, forceManyOne) {
    var batchMany = batch.many;
    var batchOne = batch.one;

    if (batchMany.length === 1 && !forceManyOne) {
      // Is one to one
      var batchFrom = fromIsMany ? batchMany[0] : batchOne;
      var batchTo = fromIsMany ? batchOne : batchMany[0];

      if ((0,zrender_lib_tool_morphPath_js__WEBPACK_IMPORTED_MODULE_3__.isCombineMorphing)(batchFrom)) {
        // Keep doing combine animation.
        morphOneBatch({
          many: [batchFrom],
          one: batchTo
        }, true, animateIndex, animateCount, true);
      } else {
        var individualAnimationCfg = animationDelay ? (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.defaults)({
          delay: animationDelay(animateIndex, animateCount)
        }, animationCfg) : animationCfg;
        (0,zrender_lib_tool_morphPath_js__WEBPACK_IMPORTED_MODULE_3__.morphPath)(batchFrom, batchTo, individualAnimationCfg);
        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);
      }
    } else {
      var separateAnimationCfg = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.defaults)({
        dividePath: pathDividers[divideShape],
        individualDelay: animationDelay && function (idx, count, fromPath, toPath) {
          return animationDelay(idx + animateIndex, animateCount);
        }
      }, animationCfg);

      var _a = fromIsMany ? (0,zrender_lib_tool_morphPath_js__WEBPACK_IMPORTED_MODULE_3__.combineMorph)(batchMany, batchOne, separateAnimationCfg) : (0,zrender_lib_tool_morphPath_js__WEBPACK_IMPORTED_MODULE_3__.separateMorph)(batchOne, batchMany, separateAnimationCfg),
          fromIndividuals = _a.fromIndividuals,
          toIndividuals = _a.toIndividuals;

      var count = fromIndividuals.length;

      for (var k = 0; k < count; k++) {
        var individualAnimationCfg = animationDelay ? (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.defaults)({
          delay: animationDelay(k, count)
        }, animationCfg) : animationCfg;
        animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany ? batchMany[k] : batch.one, fromIsMany ? batch.one : batchMany[k], individualAnimationCfg);
      }
    }
  }

  var fromIsMany = many ? many === from // Is one to one. If the path number not match. also needs do merge and separate morphing.
  : from.length > to.length;
  var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);
  var animateCount = 0;

  for (var i = 0; i < morphBatches.length; i++) {
    animateCount += morphBatches[i].many.length;
  }

  var animateIndex = 0;

  for (var i = 0; i < morphBatches.length; i++) {
    morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);
    animateIndex += morphBatches[i].many.length;
  }
}
function getPathList(elements) {
  if (!elements) {
    return [];
  }

  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(elements)) {
    var pathList_1 = [];

    for (var i = 0; i < elements.length; i++) {
      pathList_1.push(getPathList(elements[i]));
    }

    return pathList_1;
  }

  var pathList = [];
  elements.traverse(function (el) {
    if (el instanceof _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__["default"] && !el.disableMorphing && !el.invisible && !el.ignore) {
      pathList.push(el);
    }
  });
  return pathList;
}

/***/ }),

/***/ "./node_modules/echarts/lib/animation/universalTransition.js":
/*!*******************************************************************!*\
  !*** ./node_modules/echarts/lib/animation/universalTransition.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   installUniversalTransition: () => (/* binding */ installUniversalTransition)
/* harmony export */ });
/* harmony import */ var _model_Series_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../model/Series.js */ "./node_modules/echarts/lib/model/Series.js");
/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zrender/lib/core/util.js */ "./node_modules/zrender/lib/core/util.js");
/* harmony import */ var _morphTransitionHelper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./morphTransitionHelper.js */ "./node_modules/echarts/lib/animation/morphTransitionHelper.js");
/* harmony import */ var zrender_lib_graphic_Path_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zrender/lib/graphic/Path.js */ "./node_modules/zrender/lib/graphic/Path.js");
/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./basicTransition.js */ "./node_modules/echarts/lib/animation/basicTransition.js");
/* harmony import */ var _data_DataDiffer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../data/DataDiffer.js */ "./node_modules/echarts/lib/data/DataDiffer.js");
/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/model.js */ "./node_modules/echarts/lib/util/model.js");
/* harmony import */ var _util_log_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/log.js */ "./node_modules/echarts/lib/util/log.js");
/* harmony import */ var zrender_lib_graphic_Displayable_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zrender/lib/graphic/Displayable.js */ "./node_modules/zrender/lib/graphic/Displayable.js");

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/


/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
// Universal transitions that can animate between any shapes(series) and any properties in any amounts.










var DATA_COUNT_THRESHOLD = 1e4;
;
var getUniversalTransitionGlobalStore = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__.makeInner)();

function getGroupIdDimension(data) {
  var dimensions = data.dimensions;

  for (var i = 0; i < dimensions.length; i++) {
    var dimInfo = data.getDimensionInfo(dimensions[i]);

    if (dimInfo && dimInfo.otherDims.itemGroupId === 0) {
      return dimensions[i];
    }
  }
}

function flattenDataDiffItems(list) {
  var items = [];
  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(list, function (seriesInfo) {
    var data = seriesInfo.data;

    if (data.count() > DATA_COUNT_THRESHOLD) {
      if (true) {
        (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__.warn)('Universal transition is disabled on large data > 10k.');
      }

      return;
    }

    var indices = data.getIndices();
    var groupDim = getGroupIdDimension(data);

    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {
      items.push({
        dataGroupId: seriesInfo.dataGroupId,
        data: data,
        dim: seriesInfo.dim || groupDim,
        divide: seriesInfo.divide,
        dataIndex: dataIndex
      });
    }
  });
  return items;
}

function fadeInElement(newEl, newSeries, newIndex) {
  newEl.traverse(function (el) {
    if (el instanceof zrender_lib_graphic_Path_js__WEBPACK_IMPORTED_MODULE_3__["default"]) {
      // TODO use fade in animation for target element.
      (0,_util_graphic_js__WEBPACK_IMPORTED_MODULE_4__.initProps)(el, {
        style: {
          opacity: 0
        }
      }, newSeries, {
        dataIndex: newIndex,
        isFrom: true
      });
    }
  });
}

function removeEl(el) {
  if (el.parent) {
    // Bake parent transform to element.
    // So it can still have proper transform to transition after it's removed.
    var computedTransform = el.getComputedTransform();
    el.setLocalTransform(computedTransform);
    el.parent.remove(el);
  }
}

function stopAnimation(el) {
  el.stopAnimation();

  if (el.isGroup) {
    el.traverse(function (child) {
      child.stopAnimation();
    });
  }
}

function animateElementStyles(el, dataIndex, seriesModel) {
  var animationConfig = (0,_util_graphic_js__WEBPACK_IMPORTED_MODULE_4__.getAnimationConfig)('update', seriesModel, dataIndex);
  animationConfig && el.traverse(function (child) {
    if (child instanceof zrender_lib_graphic_Displayable_js__WEBPACK_IMPORTED_MODULE_5__["default"]) {
      var oldStyle = (0,_util_graphic_js__WEBPACK_IMPORTED_MODULE_4__.getOldStyle)(child);

      if (oldStyle) {
        child.animateFrom({
          style: oldStyle
        }, animationConfig);
      }
    }
  });
}

function isAllIdSame(oldDiffItems, newDiffItems) {
  var len = oldDiffItems.length;

  if (len !== newDiffItems.length) {
    return false;
  }

  for (var i = 0; i < len; i++) {
    var oldItem = oldDiffItems[i];
    var newItem = newDiffItems[i];

    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {
      return false;
    }
  }

  return true;
}

function transitionBetween(oldList, newList, api) {
  var oldDiffItems = flattenDataDiffItems(oldList);
  var newDiffItems = flattenDataDiffItems(newList);

  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {
    if (rawFrom || from) {
      to.animateFrom({
        style: rawFrom && rawFrom !== from ? // dividingMethod like clone may override the style(opacity)
        // So extend it to raw style.
        (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, rawFrom.style), from.style) : from.style
      }, animationCfg);
    }
  }

  function findKeyDim(items) {
    for (var i = 0; i < items.length; i++) {
      if (items[i].dim) {
        return items[i].dim;
      }
    }
  }

  var oldKeyDim = findKeyDim(oldDiffItems);
  var newKeyDim = findKeyDim(newDiffItems);
  var hasMorphAnimation = false;

  function createKeyGetter(isOld, onlyGetId) {
    return function (diffItem) {
      var data = diffItem.data;
      var dataIndex = diffItem.dataIndex; // TODO if specified dim

      if (onlyGetId) {
        return data.getId(dataIndex);
      } // Use group id as transition key by default.
      // So we can achieve multiple to multiple animation like drilldown / up naturally.
      // If group id not exits. Use id instead. If so, only one to one transition will be applied.


      var dataGroupId = diffItem.dataGroupId; // If specified key dimension(itemGroupId by default). Use this same dimension from other data.
      // PENDING: If only use key dimension of newData.

      var keyDim = isOld ? oldKeyDim || newKeyDim : newKeyDim || oldKeyDim;
      var dimInfo = keyDim && data.getDimensionInfo(keyDim);
      var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;

      if (dimInfo) {
        // Get from encode.itemGroupId.
        var key = data.get(dimInfo.name, dataIndex);

        if (dimOrdinalMeta) {
          return dimOrdinalMeta.categories[key] || key + '';
        }

        return key + '';
      } // Get groupId from raw item. { groupId: '' }


      var itemVal = data.getRawDataItem(dataIndex);

      if (itemVal && itemVal.groupId) {
        return itemVal.groupId + '';
      }

      return dataGroupId || data.getId(dataIndex);
    };
  } // Use id if it's very likely to be an one to one animation
  // It's more robust than groupId
  // TODO Check if key dimension is specified.


  var useId = isAllIdSame(oldDiffItems, newDiffItems);
  var isElementStillInChart = {};

  if (!useId) {
    // We may have different diff strategy with basicTransition if we use other dimension as key.
    // If so, we can't simply check if oldEl is same with newEl. We need a map to check if oldEl is still being used in the new chart.
    // We can't use the elements that already being morphed. Let it keep it's original basic transition.
    for (var i = 0; i < newDiffItems.length; i++) {
      var newItem = newDiffItems[i];
      var el = newItem.data.getItemGraphicEl(newItem.dataIndex);

      if (el) {
        isElementStillInChart[el.id] = true;
      }
    }
  }

  function updateOneToOne(newIndex, oldIndex) {
    var oldItem = oldDiffItems[oldIndex];
    var newItem = newDiffItems[newIndex];
    var newSeries = newItem.data.hostModel; // TODO Mark this elements is morphed and don't morph them anymore

    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
    var newEl = newItem.data.getItemGraphicEl(newItem.dataIndex); // Can't handle same elements.

    if (oldEl === newEl) {
      newEl && animateElementStyles(newEl, newItem.dataIndex, newSeries);
      return;
    }

    if ( // We can't use the elements that already being morphed
    oldEl && isElementStillInChart[oldEl.id]) {
      return;
    }

    if (newEl) {
      // TODO: If keep animating the group in case
      // some of the elements don't want to be morphed.
      // TODO Label?
      stopAnimation(newEl);

      if (oldEl) {
        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.

        removeEl(oldEl);
        hasMorphAnimation = true;
        (0,_morphTransitionHelper_js__WEBPACK_IMPORTED_MODULE_6__.applyMorphAnimation)((0,_morphTransitionHelper_js__WEBPACK_IMPORTED_MODULE_6__.getPathList)(oldEl), (0,_morphTransitionHelper_js__WEBPACK_IMPORTED_MODULE_6__.getPathList)(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);
      } else {
        fadeInElement(newEl, newSeries, newIndex);
      }
    } // else keep oldEl leaving animation.

  }

  new _data_DataDiffer_js__WEBPACK_IMPORTED_MODULE_7__["default"](oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, 'multiple').update(updateOneToOne).updateManyToOne(function (newIndex, oldIndices) {
    var newItem = newDiffItems[newIndex];
    var newData = newItem.data;
    var newSeries = newData.hostModel;
    var newEl = newData.getItemGraphicEl(newItem.dataIndex);
    var oldElsList = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.filter)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map)(oldIndices, function (idx) {
      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);
    }), function (oldEl) {
      return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id];
    });

    if (newEl) {
      stopAnimation(newEl);

      if (oldElsList.length) {
        // If old element is doing leaving animation. stop it and remove it immediately.
        (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(oldElsList, function (oldEl) {
          stopAnimation(oldEl);
          removeEl(oldEl);
        });
        hasMorphAnimation = true;
        (0,_morphTransitionHelper_js__WEBPACK_IMPORTED_MODULE_6__.applyMorphAnimation)((0,_morphTransitionHelper_js__WEBPACK_IMPORTED_MODULE_6__.getPathList)(oldElsList), (0,_morphTransitionHelper_js__WEBPACK_IMPORTED_MODULE_6__.getPathList)(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);
      } else {
        fadeInElement(newEl, newSeries, newItem.dataIndex);
      }
    } // else keep oldEl leaving animation.

  }).updateOneToMany(function (newIndices, oldIndex) {
    var oldItem = oldDiffItems[oldIndex];
    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex); // We can't use the elements that already being morphed

    if (oldEl && isElementStillInChart[oldEl.id]) {
      return;
    }

    var newElsList = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.filter)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map)(newIndices, function (idx) {
      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);
    }), function (el) {
      return el && el !== oldEl;
    });
    var newSeris = newDiffItems[newIndices[0]].data.hostModel;

    if (newElsList.length) {
      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(newElsList, function (newEl) {
        return stopAnimation(newEl);
      });

      if (oldEl) {
        stopAnimation(oldEl); // If old element is doing leaving animation. stop it and remove it immediately.

        removeEl(oldEl);
        hasMorphAnimation = true;
        (0,_morphTransitionHelper_js__WEBPACK_IMPORTED_MODULE_6__.applyMorphAnimation)((0,_morphTransitionHelper_js__WEBPACK_IMPORTED_MODULE_6__.getPathList)(oldEl), (0,_morphTransitionHelper_js__WEBPACK_IMPORTED_MODULE_6__.getPathList)(newElsList), oldItem.divide, // Use divide on old.
        newSeris, newIndices[0], updateMorphingPathProps);
      } else {
        (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(newElsList, function (newEl) {
          return fadeInElement(newEl, newSeris, newIndices[0]);
        });
      }
    } // else keep oldEl leaving animation.

  }).updateManyToMany(function (newIndices, oldIndices) {
    // If two data are same and both have groupId.
    // Normally they should be diff by id.
    new _data_DataDiffer_js__WEBPACK_IMPORTED_MODULE_7__["default"](oldIndices, newIndices, function (rawIdx) {
      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);
    }, function (rawIdx) {
      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);
    }).update(function (newIndex, oldIndex) {
      // Use the original index
      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);
    }).execute();
  }).execute();

  if (hasMorphAnimation) {
    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(newList, function (_a) {
      var data = _a.data;
      var seriesModel = data.hostModel;
      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);
      var animationCfg = (0,_util_graphic_js__WEBPACK_IMPORTED_MODULE_4__.getAnimationConfig)('update', seriesModel, 0); // use 0 index.

      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {
        view.group.traverse(function (el) {
          if (el instanceof zrender_lib_graphic_Path_js__WEBPACK_IMPORTED_MODULE_3__["default"] && !el.animators.length) {
            // We can't accept there still exists element that has no animation
            // if universalTransition is enabled
            el.animateFrom({
              style: {
                opacity: 0
              }
            }, animationCfg);
          }
        });
      }
    });
  }
}

function getSeriesTransitionKey(series) {
  var seriesKey = series.getModel('universalTransition').get('seriesKey');

  if (!seriesKey) {
    // Use series id by default.
    return series.id;
  }

  return seriesKey;
}

function convertArraySeriesKeyToString(seriesKey) {
  if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(seriesKey)) {
    // Order independent.
    return seriesKey.sort().join(',');
  }

  return seriesKey;
}

function getDivideShapeFromData(data) {
  if (data.hostModel) {
    return data.hostModel.getModel('universalTransition').get('divideShape');
  }
}

function findTransitionSeriesBatches(globalStore, params) {
  var updateBatches = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.createHashMap)();
  var oldDataMap = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.createHashMap)(); // Map that only store key in array seriesKey.
  // Which is used to query the old data when transition from one to multiple series.

  var oldDataMapForSplit = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.createHashMap)();
  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(globalStore.oldSeries, function (series, idx) {
    var oldDataGroupId = globalStore.oldDataGroupIds[idx];
    var oldData = globalStore.oldData[idx];
    var transitionKey = getSeriesTransitionKey(series);
    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
    oldDataMap.set(transitionKeyStr, {
      dataGroupId: oldDataGroupId,
      data: oldData
    });

    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(transitionKey)) {
      // Same key can't in different array seriesKey.
      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(transitionKey, function (key) {
        oldDataMapForSplit.set(key, {
          key: transitionKeyStr,
          dataGroupId: oldDataGroupId,
          data: oldData
        });
      });
    }
  });

  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {
    if (updateBatches.get(transitionKeyStr)) {
      (0,_util_log_js__WEBPACK_IMPORTED_MODULE_2__.warn)("Duplicated seriesKey in universalTransition " + transitionKeyStr);
    }
  }

  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(params.updatedSeries, function (series) {
    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {
      var newDataGroupId = series.get('dataGroupId');
      var newData = series.getData();
      var transitionKey = getSeriesTransitionKey(series);
      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey); // Only transition between series with same id.

      var oldData = oldDataMap.get(transitionKeyStr); // string transition key is the best match.

      if (oldData) {
        if (true) {
          checkTransitionSeriesKeyDuplicated(transitionKeyStr);
        } // TODO check if data is same?


        updateBatches.set(transitionKeyStr, {
          oldSeries: [{
            dataGroupId: oldData.dataGroupId,
            divide: getDivideShapeFromData(oldData.data),
            data: oldData.data
          }],
          newSeries: [{
            dataGroupId: newDataGroupId,
            divide: getDivideShapeFromData(newData),
            data: newData
          }]
        });
      } else {
        // Transition from multiple series.
        if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(transitionKey)) {
          if (true) {
            checkTransitionSeriesKeyDuplicated(transitionKeyStr);
          }

          var oldSeries_1 = [];
          (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(transitionKey, function (key) {
            var oldData = oldDataMap.get(key);

            if (oldData.data) {
              oldSeries_1.push({
                dataGroupId: oldData.dataGroupId,
                divide: getDivideShapeFromData(oldData.data),
                data: oldData.data
              });
            }
          });

          if (oldSeries_1.length) {
            updateBatches.set(transitionKeyStr, {
              oldSeries: oldSeries_1,
              newSeries: [{
                dataGroupId: newDataGroupId,
                data: newData,
                divide: getDivideShapeFromData(newData)
              }]
            });
          }
        } else {
          // Try transition to multiple series.
          var oldData_1 = oldDataMapForSplit.get(transitionKey);

          if (oldData_1) {
            var batch = updateBatches.get(oldData_1.key);

            if (!batch) {
              batch = {
                oldSeries: [{
                  dataGroupId: oldData_1.dataGroupId,
                  data: oldData_1.data,
                  divide: getDivideShapeFromData(oldData_1.data)
                }],
                newSeries: []
              };
              updateBatches.set(oldData_1.key, batch);
            }

            batch.newSeries.push({
              dataGroupId: newDataGroupId,
              data: newData,
              divide: getDivideShapeFromData(newData)
            });
          }
        }
      }
    }
  });
  return updateBatches;
}

function querySeries(series, finder) {
  for (var i = 0; i < series.length; i++) {
    var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;

    if (found) {
      return i;
    }
  }
}

function transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {
  var from = [];
  var to = [];
  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)((0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__.normalizeToArray)(transitionOpt.from), function (finder) {
    var idx = querySeries(globalStore.oldSeries, finder);

    if (idx >= 0) {
      from.push({
        dataGroupId: globalStore.oldDataGroupIds[idx],
        data: globalStore.oldData[idx],
        // TODO can specify divideShape in transition.
        divide: getDivideShapeFromData(globalStore.oldData[idx]),
        dim: finder.dimension
      });
    }
  });
  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)((0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__.normalizeToArray)(transitionOpt.to), function (finder) {
    var idx = querySeries(params.updatedSeries, finder);

    if (idx >= 0) {
      var data = params.updatedSeries[idx].getData();
      to.push({
        dataGroupId: globalStore.oldDataGroupIds[idx],
        data: data,
        divide: getDivideShapeFromData(data),
        dim: finder.dimension
      });
    }
  });

  if (from.length > 0 && to.length > 0) {
    transitionBetween(from, to, api);
  }
}

function installUniversalTransition(registers) {
  registers.registerUpdateLifecycle('series:beforeupdate', function (ecMOdel, api, params) {
    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)((0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__.normalizeToArray)(params.seriesTransition), function (transOpt) {
      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)((0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__.normalizeToArray)(transOpt.to), function (finder) {
        var series = params.updatedSeries;

        for (var i = 0; i < series.length; i++) {
          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {
            series[i][_model_Series_js__WEBPACK_IMPORTED_MODULE_8__.SERIES_UNIVERSAL_TRANSITION_PROP] = true;
          }
        }
      });
    });
  });
  registers.registerUpdateLifecycle('series:transition', function (ecModel, api, params) {
    // TODO api provide an namespace that can save stuff per instance
    var globalStore = getUniversalTransitionGlobalStore(api); // TODO multiple to multiple series.

    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {
      // Use give transition config if its' give;
      var transitionOpt = params.seriesTransition;

      if (transitionOpt) {
        (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)((0,_util_model_js__WEBPACK_IMPORTED_MODULE_0__.normalizeToArray)(transitionOpt), function (opt) {
          transitionSeriesFromOpt(opt, globalStore, params, api);
        });
      } else {
        // Else guess from series based on transition series key.
        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);
        (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(updateBatches_1.keys(), function (key) {
          var batch = updateBatches_1.get(key);
          transitionBetween(batch.oldSeries, batch.newSeries, api);
        });
      } // Reset


      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(params.updatedSeries, function (series) {
        // Reset;
        if (series[_model_Series_js__WEBPACK_IMPORTED_MODULE_8__.SERIES_UNIVERSAL_TRANSITION_PROP]) {
          series[_model_Series_js__WEBPACK_IMPORTED_MODULE_8__.SERIES_UNIVERSAL_TRANSITION_PROP] = false;
        }
      });
    } // Save all series of current update. Not only the updated one.


    var allSeries = ecModel.getSeries();
    var savedSeries = globalStore.oldSeries = [];
    var savedDataGroupIds = globalStore.oldDataGroupIds = [];
    var savedData = globalStore.oldData = [];

    for (var i = 0; i < allSeries.length; i++) {
      var data = allSeries[i].getData(); // Only save the data that can have transition.
      // Avoid large data costing too much extra memory

      if (data.count() < DATA_COUNT_THRESHOLD) {
        savedSeries.push(allSeries[i]);
        savedDataGroupIds.push(allSeries[i].get('dataGroupId'));
        savedData.push(data);
      }
    }
  });
}

/***/ })

}]);